"use strict";
function Sprite(options) {
    //var path = options.path;
    var width = options.width;
    var height = options.height;
    var frames = options.frames;
    var duration = options.duration;
    var context = options.context;

    var frame = 0;
}

Sprite.prototype = {
    draw: function draw(point) {
    }
};
"use strict";
// Find angle between two points.
function getAngle(p1, p2) {
    return Math.atan2(p2.y - p1.y, p2.x - p1.x) * 180 / Math.PI;
}

// Euclidean modulo.
function mod(x, value) {
    return x >= 0 ? x % value : value + x % value;
}

// Distance between two points.
function lineDistance(point1, point2) {
    var xs = 0;
    var ys = 0;

    xs = point2.x - point1.x;
    xs = xs * xs;

    ys = point2.y - point1.y;
    ys = ys * ys;

    return Math.sqrt(xs + ys);
}

// Point from distance and angle
function pointFromAngle(point, angle, distance) {
    var radians = angle * (Math.PI / 180);

    var x = Math.cos(radians) * distance;
    var y = Math.sin(radians) * distance;

    x = point.x + x;
    y = point.y + y;

    return { x: x, y: y };
}

//function Point(x, y) {
//    return { x: x, y: y }
//}


// Returns a random number between min and max.
function getRandomArbitary(min, max) {
    return Math.random() * (max - min) + min;
}

// Returns a random integer between min and max.
function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

// Return true x percent of the time.
function chance(percentage) {
    return Math.random() * 100 < percentage;
}

// Returns the angle if ship1 is facing ship2.
function isFacing(ship1, ship2) {
    var result = false;
    var diff = getAngle(ship1.center, ship2.center) - ship1.angle;
    if (Math.abs(diff) < 100)
        result = diff;

    return result;
}

// http://gamedev.stackexchange.com/a/26022/36040
function isIntersecting1(Point1, Point2, Point3, Point4) {
    var denominator = ((Point2.x - Point1.x) * (Point4.y - Point3.y)) - ((Point2.y - Point1.y) * (Point4.x - Point3.x));
    var numerator1 = ((Point1.y - Point3.y) * (Point4.x - Point3.x)) - ((Point1.x - Point3.x) * (Point4.y - Point3.y));
    var numerator2 = ((Point1.y - Point3.y) * (Point2.x - Point1.x)) - ((Point1.x - Point3.x) * (Point2.y - Point1.y));

    // Detect coincident lines (has a problem, read below)
    if (denominator == 0)
        return numerator1 == 0 && numerator2 == 0;

    var r = numerator1 / denominator;
    var s = numerator2 / denominator;

    return (r >= 0 && r <= 1) && (s >= 0 && s <= 1);
}

// Adapted from: http://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect/1968345#1968345
function line_intersects(p0_x, p0_y, p1_x, p1_y, p2_x, p2_y, p3_x, p3_y) {
    var s1_x, s1_y, s2_x, s2_y;
    s1_x = p1_x - p0_x;
    s1_y = p1_y - p0_y;
    s2_x = p3_x - p2_x;
    s2_y = p3_y - p2_y;

    var s, t;
    s = (-s1_y * (p0_x - p2_x) + s1_x * (p0_y - p2_y)) / (-s2_x * s1_y + s1_x * s2_y);
    t = (s2_x * (p0_y - p2_y) - s2_y * (p0_x - p2_x)) / (-s2_x * s1_y + s1_x * s2_y);

    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
        // Collision detected
        return 1;
    }

    return 0; // No collision
}

// http://stackoverflow.com/a/16725715/2407212
function CCW(p1, p2, p3) {
    return (p3.y - p1.y) * (p2.x - p1.x) > (p2.y - p1.y) * (p3.x - p1.x);
}

function isIntersecting(p1, p2, p3, p4) {
    return (CCW(p1, p3, p4) != CCW(p2, p3, p4)) && (CCW(p1, p2, p3) != CCW(p1, p2, p4));
}

function lineIntersectsShip(startpoint, endpoint, ship) {
    // Corners.
    var p1 = { x: ship.x, y: ship.y };
    var p2 = { x: ship.x + ship.width, y: ship.y };
    var p3 = { x: ship.x + ship.width, y: ship.y + ship.height };
    var p4 = { x: ship.x, y: ship.y + ship.height };

    // Check if bullet line intersects the ship outline.
    return isIntersecting(startpoint, endpoint, p1, p2) ||
        isIntersecting(startpoint, endpoint, p2, p3) ||
        isIntersecting(startpoint, endpoint, p3, p4) ||
        isIntersecting(startpoint, endpoint, p4, p1);
}
"use strict";
function explode(x, y, scale) {
    var explosion = document.createElement("div");
    var width;
    var height;

    explosion.className = "explosion explosion" + getRandomInt(1, 5);

    $(document.body).append(explosion);

    width = explosion.offsetWidth;
    height = explosion.offsetHeight;

    explosion.style.top = y - height / 2 + "px";
    explosion.style.left = x - width / 2 + "px";
    if (scale)
        explosion.style.transform = "scale(" + scale + ")";
    //explosion.style.transform = "rotate(" + getRandomInt(0, 359) + "deg) scale(" + (scale || getRandomArbitary(0.8, 1.2)) + ")";

    // For collision detection.
    explosion.x = x;
    explosion.y = y;
    explosion.width = width / 2;
    explosion.height = height / 2;
    explosions.push(explosion);

    explosionSound.play();
}

// Bind end to explosion.
document.addEventListener('transitionend',
function (event) {
    var $target = $(event.target);
    // Missile.
    if ($target.hasClass("missile") && event.propertyName === 'top') { // Keep from firing for each attr.
        //console.log("Missile: " + event.type + " " + event.timeStamp);
        //alert("KILL KILL!");
        explode(
          $target.offset().left - $target.width() / 2,
          $target.offset().top - $target.height() / 2
        );
        $target.remove();
    }
});

// TODO: add webkit prefix (multi listener: http://stackoverflow.com/a/8797106/2407212)
document.addEventListener('animationend',
function (event) {
    var $target = $(event.target);
    // Explosion.
    if ($target.hasClass("explosion")) {
        //console.log("Explosion: type'" + event.target.className + "' " + event.type + " " + event.timeStamp);
        $target.remove();
        //alert("Boom!");
    }
});


/*
var paint = [];
function paintMadness() {
    // PAINT MADNESS.
    // Record.
    if (keyDown[KEYS.KEY_Q]) {
        paint.push(mousePosition);
    }
    // Shoot path.
    if (keyDown[KEYS.KEY_E]) {
        if (paint.length) {
            fireMissile(player.center, paint[0]);
            fireMissile(player.center, paint[~~(paint.length / 5)]);
            fireMissile(player.center, paint[~~(paint.length / 5 * 2)]);
            fireMissile(player.center, paint[~~(paint.length / 5 * 3)]);
            fireMissile(player.center, paint[~~(paint.length / 5 * 4)]);
            laserSound.play();
            //paint = paint.splice(1);
            paint.push(paint.shift());
        }
    }
    // Full Kamikaze.
    if (keyDown[KEYS.KEY_F]) {
        for (var i = 0; i < paint.length; i++) {
            fireMissile(player.center, paint[i]);
            laserSound.play();
        }
    }
    // Clear last. (Doesn't work well with Array.shift)
    if (keyDown[KEYS.KEY_V]) {
        paint.pop();
    }
    // Clear all.
    if (keyDown[KEYS.KEY_R]) {
        paint = [];
    }
}
*/

// TODO use inheritance to share methods with other entities.
function Projectile(options) {
    var that = this;

    this.owner = options.owner;
    this.target = options.target;
    this.type = options.type;

    this.health = options.health || 1;
    this.damage = options.damage || 10;
    this.ctx = options.ctx;
    //this.status = {};
    //this.lastStatusChange = Infinity;

    this.speedX = options.speedX || 0;
    this.speedY = options.speedY || 0;

    this.acceleration = options.acceleration || 1;
    this.turnSpeed = options.turnSpeed || 0;

    //this.inaccuracy = 100;

    this.angle = options.angle;

    // Temp, see img.onload!
    this.width = options.width || 6;
    this.height = options.height || 12;
    this.x = options.x - this.width / 2;
    this.y = options.y - this.height / 2;
    this.center = {
        x: this.x + this.width / 2,
        y: this.y + this.height / 2
    };

    // Set projectile image.
    this.image = new Image();
    this.image.src = "images/objects/bolt1.png";

    // TODO this needs to be smarter, better measure once per image.
    // Measure it.
    this.image.onload = function () {
        that.width = that.image.width;
        that.height = that.image.height;

        that.x = options.x - that.width / 2;
        that.y = options.y - that.height / 2;

        that.center = {
            x: that.x + that.width / 2,
            y: that.y + that.height / 2
        };
    };
}

Projectile.prototype = {
    draw: function draw() {
        this.drawRotated();
    },

    drawRotated: function drawRotated(image) {
        image || (image = this.image);
        var x = this.center.x;
        var y = this.center.y;
        var context = this.ctx;
        var degrees = this.angle + 90;
        var angleInRadians = degrees * Math.PI / 180;

        context.translate(x, y);
        context.rotate(angleInRadians);
        context.drawImage(image, -this.width / 2, -this.height / 2);
        context.rotate(-angleInRadians);
        context.translate(-x, -y);
    },

    updateCenter: function updateCenter() {
        this.center.x = this.x + this.width / 2;
        this.center.y = this.y + this.height / 2;
    },

    turn: function turn(point) {
        // Find projectile angle.
        var targetAngle = getAngle(this.center, point);
        var turnDegrees = mod(targetAngle - this.angle + 180, 360) - 180;

        if (turnDegrees > -4 && turnDegrees < 4) {
            this.angle = targetAngle;
        }
        else if (turnDegrees < 0) {
            this.angle -= this.turnSpeed;
        }
        else {
            this.angle += this.turnSpeed;
        }
    },

    move: function move(directions) {
        // Angle 0 is X-axis, direction is in radians.
        var angle = this.angle * (Math.PI / 180);

        var forward = directions.forward ? 1 : 0;
        var back = directions.back ? -0.3 : 0;
        var left = directions.left ? 0.4 : 0;
        var right = directions.right ? -0.4 : 0;

        // Forward and backward.
        this.speedX = this.speedX + (forward + back) * this.acceleration * Math.cos(angle);
        this.speedY = this.speedY + (forward + back) * this.acceleration * Math.sin(angle);

        // Left and right.
        this.speedX = this.speedX + (left + right) * this.acceleration * Math.cos(angle - Math.PI / 2);
        this.speedY = this.speedY + (left + right) * this.acceleration * Math.sin(angle - Math.PI / 2);

        // Friction.
        this.speedX *= 0.985;
        this.speedY *= 0.985;

        this.x = this.x + this.speedX;
        this.y = this.y + this.speedY;

        this.updateCenter();
    },

    update: function () {
        if (this.health <= 0)
            return this.destroy();
        else if (this.x < 0 || this.y < 0 || this.x > this.ctx.canvas.width || this.y > this.ctx.canvas.height)
            return this.remove();

        //this.turn(this.target);

        // Direction modifiers.
        var directions = {
            forward: true
        };

        this.move(directions);

        this.draw();
    },

    destroy: function () {
        explode(this.center.x, this.center.y);
        projectiles = projectiles.filter(function notMe(el) { return el !== this; }, this);
    },

    remove: function () {
        projectiles = projectiles.filter(function notMe(el) { return el !== this; }, this);
    }
};

"use strict";
// Globals.
var Firefly;
var enemies = new Array(8);
var projectiles = [];
var explosions = [];
var game = true;
var laserSound = new SoundPool("sound/effects/laser.wav", 0.05, 300);
var explosionSound = new SoundPool("sound/effects/explosion4.wav", 0.1, 300);
var playlist = [
    "sound/music/ambientmain_0.ogg",
    "sound/music/dark_fallout.ogg",
    "sound/music/last_stand_in_space.ogg",
    "sound/music/dust.mp3"
];
var backgroundAudio = new Playlist(playlist, 0.2, true);
var canvas;

// Initialize game.
document.addEventListener("DOMContentLoaded", function () {
    //backgroundAudio.play();

    //disableKeys([KEYS.F1, KEYS.F5]);

    canvas = document.getElementById("canvas");
    canvas.ctx = canvas.getContext("2d");

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    window.onresize = function () {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    };

    canvas.bg = new Image();
    canvas.bg.src = "images/bg.jpg";

    Firefly = createPlayer(canvas);

    for (var i = 0; i < enemies.length; i++) {
        enemies[i] = createEnemy(canvas);
        //enemies[i].init();
    }

    // Delay start till ship ready.
    window.setTimeout(render, 50);
});

function render() {
    if (!game) return;
    requestAnimationFrame(render);

    canvas.ctx.clearRect(0, 0, canvas.width, canvas.height);
    canvas.ctx.drawImage(canvas.bg, 0, 0);

    // Check ships vs explosions.
    for (var e = 0; e < explosions.length; e++) {
        for (var j = 0; j < enemies.length; j++) {
            if (isColliding(explosions[e], enemies[j]))
                enemies[j].health--;
        }
        // Check player.
        if (isColliding(explosions[e], Firefly))
            Firefly.health--;
    }
    // Reset explosions.
    explosions = [];

    // Check ships vs projectiles.
    for (var p = 0; p < projectiles.length; p++) {
        for (var j = 0; j < enemies.length; j++) {
            // Check for friendly fire as well.
            if (projectiles[p].owner === Firefly && isColliding(projectiles[p], enemies[j])) {
                enemies[j].health -= projectiles[p].damage;
                projectiles[p].health = 0;
            }
        }
        // Check player.
        if (projectiles[p].owner !== Firefly && isColliding(projectiles[p], Firefly)) {
            Firefly.health -= projectiles[p].damage;
            projectiles[p].health = 0;
        }
    }

    Firefly.update();

    for (var i = 0; i < projectiles.length; i++) {
        projectiles[i].update();
    }

    for (var i = 0; i < enemies.length; i++) {
        enemies[i].update();
    }

    // HP bar.
    ui.showHealth(canvas.ctx, Firefly);
}

// **isColliding()** returns true if two passed bodies are colliding.
// The approach is to test for five situations.  If any are true,
// the bodies are definitely not colliding. If none of them
// are true, the bodies are colliding.
// 1. b1 is the same body as b2.
// 2. Right of `b1` is to the left of the left of `b2`.
// 3. Bottom of `b1` is above the top of `b2`.
// 4. Left of `b1` is to the right of the right of `b2`.
// 5. Top of `b1` is below the bottom of `b2`.
function isColliding(b1, b2) {
    return !(
        b1 === b2 ||
        b1.x + b1.width < b2.x - b2.width ||
        b1.y + b1.height < b2.y - b2.height ||
        b1.x - b1.width > b2.x + b2.width ||
        b1.y - b1.height > b2.y + b2.height
    );
}

// Ship constructor.
function Ship(canvas, options) {
    var that = this;

    this.health = 50;

    //this.damage = 10;
    this.ctx = canvas.ctx;
    this.status = {};
    this.lastStatusChange = Infinity;

    this.speedX = 0;
    this.speedY = 0;

    this.acceleration = 0.3;
    this.turnSpeed = 3;
    this.cooldownTime = 20;
    this.inaccuracy = 100;

    // Can fire.
    this.cooldown = 0;
    this.x = window.innerWidth / 2 - 40;
    this.y = window.innerHeight / 2 - 40;
    this.angle = 0;

    this.width = 50;
    this.height = 50;

    this.fireImg = new Image();
    this.fireImg.src = "images/objects/GunFlare.png";

    this.takingFireImg = new Image();
    this.takingFireImg.src = "images/objects/BulletImpact.png";

    // Customize properties.
    Object.extend(this, options);

    this.maxHealth = this.health;

    this.center = {
        x: this.x + this.width / 2,
        y: this.y + this.height / 2
    };

    // Set ship image.
    this.image = new Image();
    this.image.src = this.imageSrc;

    // Measure it.
    this.image.onload = function () {
        that.width = that.image.width;
        that.height = that.image.height;
        that.center = {
            x: that.x + that.width / 2,
            y: that.y + that.height / 2
        };
    };
}

Ship.prototype = {
    draw: function draw() {
        this.drawRotated();

        if (this.status.firing)
            this.drawRotated(this.fireImg);

        if (this.status.takingFire)
            this.drawRotated(this.takingFireImg);
    },

    drawRotated: function drawRotated(image) {
        image || (image = this.image);
        var x = this.center.x;
        var y = this.center.y;
        var context = this.ctx;
        var degrees = this.angle + 90;
        var angleInRadians = degrees * Math.PI / 180;

        context.translate(x, y);
        context.rotate(angleInRadians);
        context.drawImage(image, -this.width / 2, -this.height / 2);
        context.rotate(-angleInRadians);
        context.translate(-x, -y);
    },

    // Set center.
    updateCenter: function updateCenter() {
        this.center.x = this.x + this.width / 2;
        this.center.y = this.y + this.height / 2;
    },

    // Set the ships angle.
    turn: function turn(point) {
        // Find ship angle.
        var targetAngle = getAngle(this.center, point);
        var turnDegrees = mod(targetAngle - this.angle + 180, 360) - 180;

        if (turnDegrees > -4 && turnDegrees < 4) {
            this.angle = targetAngle;
        }
        else if (turnDegrees < 0) {
            this.angle -= this.turnSpeed;
        }
        else {
            this.angle += this.turnSpeed;
        }
    },

    // TODO Only works for player.
    fireGun: function fireGun() {
        if (this.cooldown > 0)
            return;

        this.status.firing = true;

        // Long gun range.
        var endpoint = pointFromAngle(this.center, this.angle, 10000);
        var intersecting = [];

        for (var i = 0; i < enemies.length; i++) {
            if (lineIntersectsShip(this.center, endpoint, enemies[i]))
                intersecting.push(enemies[i]);
        }

        // todo: only is cleared when firing! Status should be maintained per ship update.
        //enemies[i].status.takingFire = false;

        var target;
        var distance1 = Infinity;
        var distance2;

        // Only hit closest target.
        for (var i = 0; i < intersecting.length; i++) {
            distance2 = lineDistance(this.center, intersecting[i].center);
            if (distance2 < distance1) {
                distance1 = distance2;
                target = intersecting[i];
            }
        }

        if (target) {
            target.status.takingFire = true;
            target.lastStatusChange = 0;
            target.health--;
            endpoint = pointFromAngle(this.center, this.angle, distance1);
        }

        // Draw double laser.
        var offset = 12;
        var p1 = pointFromAngle(this.center, this.angle - 90, offset);
        var p2 = pointFromAngle(this.center, this.angle - 90, -offset);
        var t1 = pointFromAngle(endpoint, this.angle - 90, offset);
        var t2 = pointFromAngle(endpoint, this.angle - 90, -offset);

        var context = this.ctx;
        context.beginPath();

        context.moveTo(p1.x, p1.y);
        context.lineTo(t1.x, t1.y);
        context.moveTo(p2.x, p2.y);
        context.lineTo(t2.x, t2.y);

        context.lineWidth = 0.8;
        //context.setLineDash([1]);
        context.strokeStyle = 'orange';
        context.stroke();

        this.cooldown = this.cooldownTime;
        laserSound.play();
    },

    fireMissile: function fireMissile(launchPoint, target) {
        var missileOptions = {
            owner: this,
            // TODO: target doesn't have use for dumbfire
            //target: target,
            x: launchPoint.x,
            y: launchPoint.y,
            type: 'dumbfire',
            ctx: this.ctx,
            angle: this.angle,
            speedX: this.speedX,
            speedY: this.speedY
        };

        projectiles.push(new Projectile(missileOptions));
    },

    move: function move(directions) {
        // Angle 0 is X-axis, direction is in radians.
        var angle = this.angle * (Math.PI / 180);

        var forward = directions.forward ? 1 : 0;
        var back = directions.back ? -0.3 : 0;
        var left = directions.left ? 0.4 : 0;
        var right = directions.right ? -0.4 : 0;

        // Forward and backward.
        this.speedX = this.speedX + (forward + back) * this.acceleration * Math.cos(angle);
        this.speedY = this.speedY + (forward + back) * this.acceleration * Math.sin(angle);

        // Left and right.
        this.speedX = this.speedX + (left + right) * this.acceleration * Math.cos(angle - Math.PI / 2);
        this.speedY = this.speedY + (left + right) * this.acceleration * Math.sin(angle - Math.PI / 2);

        // Friction.
        this.speedX *= 0.985;
        this.speedY *= 0.985;

        this.x = this.x + this.speedX;
        this.y = this.y + this.speedY;

        this.updateCenter();
    }
};

function createPlayer(canvas) {
    var player = new Ship(canvas, {
        acceleration: 0.8,
        turnSpeed: 6,
        health: 500,
        // Explosions baby!
        cooldownTime: 5,
        imageSrc: "images/objects/Firefly.png",

        update: function () {
            if (this.health <= 0)
                return this.destroy();

            // Reset stati.
            this.status = {};

            this.turn(mousePosition);

            // Find the direction modifiers for player.
            var directions = {
                forward: keyDown[KEYS.UP_ARROW] || keyDown[KEYS.KEY_W],
                back: keyDown[KEYS.DOWN_ARROW] || keyDown[KEYS.KEY_S],
                left: keyDown[KEYS.LEFT_ARROW] || keyDown[KEYS.KEY_A],
                right: keyDown[KEYS.RIGHT_ARROW] || keyDown[KEYS.KEY_D]
            };

            this.move(directions);
            //if (!movement) this.elem.classList.remove("moving");

            // Firing.
            if (this.cooldown < 1) {
                if (keyDown[KEYS.SPACE]) {
                    var offset = this.width / 2.4;
                    var p1 = pointFromAngle(this.center, this.angle - 90, offset);
                    var p2 = pointFromAngle(this.center, this.angle - 90, -offset);

                    var t1 = pointFromAngle(mousePosition, this.angle - 90, offset * 0.5);
                    var t2 = pointFromAngle(mousePosition, this.angle - 90, -offset * 0.5);

                    this.fireMissile(p1, t1);
                    this.fireMissile(p2, t2);
                    this.cooldown = this.cooldownTime;
                    laserSound.play();
                }

                // Lasers!
                if (mouseDown[BUTTONS.LEFT]) {
                    this.fireGun();
                }
            }
            else
                this.cooldown--;

            // Do paint madness.
            //paintMadness();

            this.draw();
        },

        destroy: function () {
            // TODO: mad loop with game state...
            explode(this.center.x, this.center.y, 5);
            //this.elem.parentElement.removeChild(this.elem);

            //game.remove(this);
            //Firefly = "game over";
            //game = false;
            //pauseGame();
            alert("Game over!");
            // Make enemies go mad? :)
        }
    });

    return player;
}

function createEnemy(canvas) {
    var enemy = new Ship(canvas, {
        speed: 5,
        x: chance(50) ? getRandomInt(50, 300) : getRandomInt(canvas.width - 250, canvas.width - 400),
        y: chance(50) ? getRandomInt(50, 300) : getRandomInt(canvas.height - 250, canvas.height - 400),
        imageSrc: "images/objects/enemy1.png",

        //init: function () {
        //    enemy.elem.classList.add("enemy")
        //},

        update: function () {
            if (this.health <= 0)
                return this.destroy();

            // Reset status if it was set long ago. TODO: this is fubar, some getter setter maybe?
            if (this.lastStatusChange > 1) {
                this.status = {};
                this.lastStatusChange = 0;
            }
            else
                this.lastStatusChange++;

            this.turn(Firefly.center);

            // Move out of player range
            var facing = isFacing(Firefly, this);
            var directions = {};
            if (facing) {
                directions = {
                    forward: true,
                    left: facing > 0,
                    right: facing < 0
                };
            }
                // Back away.
            else if (lineDistance(this.center, Firefly.center) < 300) {
                directions = {
                    back: true
                };
            }

            this.move(directions);

            // Fire.
            if (this.cooldown < 1) {
                if (chance(1)) {
                    var target = {
                        x: Firefly.center.x + getRandomInt(-this.inaccuracy, this.inaccuracy),
                        y: Firefly.center.y + getRandomInt(-this.inaccuracy, this.inaccuracy)
                    };
                    this.fireMissile(this.center, target);
                    this.cooldown = this.cooldownTime;
                    // hardly visible, needs to be more frames.
                    this.status.firing = true;
                    laserSound.play();
                }
            }
            else {
                this.status.firing = false;
                this.cooldown--;
            }

            this.draw();
        },

        destroy: function () {
            explode(this.center.x, this.center.y, 2.5);

            //this.elem.parentNode.removeChild(this.elem);
            // Remove this from enemies list.
            //game.remove(this);
            enemies = enemies.filter(function notMe(el) { return el !== this; }, this);

            // Lame check.
            if (!enemies.length) alert("Win!");
        }
    });

    return enemy;
}
"use strict";
//var musicPlayer, speechPlayer, effectsPlayer;

var deleteMeAudio = { // TODO: replace
    togglePlayers: function (player) {
        var players;
        player ? players = [player] : players = [musicPlayer, speechPlayer, effectsPlayer];
        for (var i = 0; i < players.length; i++) {
            players[i].muted = !players[i].muted;
            settings[players[i].id] = settings[players[i].id] || {};
            settings[players[i].id].muted = players[i].muted;
        }
    },
    volumeDown: function (player) {
        var players;
        player ? players = [player] : players = [musicPlayer, speechPlayer, effectsPlayer];
        for (var i = 0; i < players.length; i++) {
            if (players[i].volume > 0)
                players[i].volume = (Math.round((players[i].volume - 0.1) * 10) / 10); // JS math error fix
            alert("Volume: " + players[i].volume * 10);
            settings[players[i].id] = settings[players[i].id] || {};
            settings[players[i].id].volume = players[i].volume;
            console.log(settings[players[i].id] + " " + players[i].id + " " + players[i].volume + " " + settings[players[i].id].volume);
        }
    },
    volumeUp: function (player) {
        var players;
        player ? players = [player] : players = [musicPlayer, speechPlayer, effectsPlayer];
        for (var i = 0; i < players.length; i++) {
            if (players[i].volume < 1)
                players[i].volume = (Math.round((players[i].volume + 0.1) * 10) / 10); // JS math error fix
            alert("Volume: " + players[i].volume * 10);
            settings[players[i].id] = settings[players[i].id] || {};
            settings[players[i].id].volume = players[i].volume;
            console.log(settings[players[i].id] + " " + players[i].id + " " + players[i].volume + " " + settings[players[i].id].volume);
        }
    },
    setVolume: function (volume, player) {
        var players;
        player ? players = [player] : players = [musicPlayer, speechPlayer, effectsPlayer];
        for (var i = 0; i < players.length; i++) {
            players[i].volume = volume;
            alert("Volume set: " + players[i].volume * 10);
        }
    },
    nextTrack: function () {
        var player = musicPlayer;
        !player.paused ? player.pause() : player.play();
    }
};

// A sound pool to use for the sound effects.
// http://blog.sklambert.com/html5-canvas-game-html5-audio-and-finishing-touches/#adding-html-audio
function SoundPool(filename, volume, maxSize) {
    var pool = [];
    this.pool = pool;
    var currSound = 0;
    var that = this;

    // Populates the pool array with the given sound.
    for (var i = 0; i < maxSize; i++) {
        var sound = new Audio(filename);
        sound.volume = volume;
        pool[i] = sound;
    }

    this.setVolume = function setVolume(volume) {
        for (var i = 0; i < that.pool.length; i++) {
            that.pool[i].volume = volume;
        }
    };

    this.mute = function mute(state) {
        for (var i = 0; i < that.pool.length; i++) {
            // State: toggle, true or false.
            if (typeof state == "undefined")
                that.pool[i].muted = !that.pool[i].muted;
            else
                that.pool[i].muted = state;
        }
    };

    // Plays a sound.
    this.play = function () {
        if (pool[currSound].currentTime == 0 || pool[currSound].ended) {
            pool[currSound].play();
        }
        currSound = (currSound + 1) % maxSize;
    };
}

// Audio playlist. Takes an array of filenames.
function Playlist(playlist, volume, random) {
    var that = this;
    var currentTrack = random ? getRandomInt(0, playlist.length - 1) : 0;
    var player = new Audio();
    player.volume = volume || 0.5;
    player.src = playlist[currentTrack];

    this.setVolume = function setVolume(volume) {
        player.volume = volume;
    };

    this.mute = function mute(state) {
        // State: toggle, true or false.
        if (typeof state == "undefined")
            player.muted = !player.muted;
        else
            player.muted = state;
    };

    this.play = function play() {
        player.play();
    };
    this.pause = function pause() { player.pause(); };

    // Next track.
    this.next = function next() {
        if (random)
            currentTrack = getRandomInt(0, playlist.length - 1);
        else
            currentTrack = (currentTrack + 1) % playlist.length;
        player.src = playlist[currentTrack];
        //console.log(playlist[currentTrack]);
        player.play();
    };

    this.isPlaying = function isPlaying() { return !player.paused; };

    player.addEventListener("ended", that.next);
}
"use strict";
var ui = {
    showHealth: function (ctx, entity) {
        var width = ctx.canvas.width * entity.health / entity.maxHealth;
        // Small bar on top of canvas.
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, ctx.canvas.width, 4);
        ctx.fillStyle = "red";
        ctx.fillRect(0, 1, width, 2);
    }
};

function newGame() {
    window.location.reload();
}

function continueGame() {
    game = true;
    render();
    $('.menu').hide();
}

function pauseGame() {
    game = false;
    $('.menu').show();
}

// Hotkeys.
document.addEventListener("keyup", function hotkeys(event) {
    // Get key by value
    var key = Object.keys(KEYS).filter(function (key) {
        return KEYS[key] === event.which;
    })[0];

    switch (key) {
        case 'ESCAPE':
        case 'PAUSE':
            if (game)
                pauseGame();
            else
                continueGame();
            break;
        default:
            break;
    }
});

"use strict";
var KEYS = { BACKSPACE: 8, TAB: 9, ENTER: 13, SHIFT: 16, CTRL: 17, ALT: 18, PAUSE: 19, CAPS_LOCK: 20, ESCAPE: 27, SPACE: 32, PAGE_UP: 33, PAGE_DOWN: 34, END: 35, HOME: 36, LEFT_ARROW: 37, UP_ARROW: 38, RIGHT_ARROW: 39, DOWN_ARROW: 40, INSERT: 45, DELETE: 46, KEY_0: 48, KEY_1: 49, KEY_2: 50, KEY_3: 51, KEY_4: 52, KEY_5: 53, KEY_6: 54, KEY_7: 55, KEY_8: 56, KEY_9: 57, KEY_A: 65, KEY_B: 66, KEY_C: 67, KEY_D: 68, KEY_E: 69, KEY_F: 70, KEY_G: 71, KEY_H: 72, KEY_I: 73, KEY_J: 74, KEY_K: 75, KEY_L: 76, KEY_M: 77, KEY_N: 78, KEY_O: 79, KEY_P: 80, KEY_Q: 81, KEY_R: 82, KEY_S: 83, KEY_T: 84, KEY_U: 85, KEY_V: 86, KEY_W: 87, KEY_X: 88, KEY_Y: 89, KEY_Z: 90, LEFT_META: 91, RIGHT_META: 92, SELECT: 93, NUMPAD_0: 96, NUMPAD_1: 97, NUMPAD_2: 98, NUMPAD_3: 99, NUMPAD_4: 100, NUMPAD_5: 101, NUMPAD_6: 102, NUMPAD_7: 103, NUMPAD_8: 104, NUMPAD_9: 105, MULTIPLY: 106, ADD: 107, SUBTRACT: 109, DECIMAL: 110, DIVIDE: 111, F1: 112, F2: 113, F3: 114, F4: 115, F5: 116, F6: 117, F7: 118, F8: 119, F9: 120, F10: 121, F11: 122, F12: 123, NUM_LOCK: 144, SCROLL_LOCK: 145, SEMICOLON: 186, EQUALS: 187, COMMA: 188, DASH: 189, PERIOD: 190, FORWARD_SLASH: 191, GRAVE_ACCENT: 192, OPEN_BRACKET: 219, BACK_SLASH: 220, CLOSE_BRACKET: 221, SINGLE_QUOTE: 222 };
var keyDown = [];
var mousePosition = { x: 0, y: 0 };
var BUTTONS = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
var mouseDown = [];
var mouseDownCount = 0;

// Keyboard state.
document.addEventListener("keydown", function (event) {
    keyDown[event.which] = true;
});

document.addEventListener("keyup", function (event) {
    keyDown[event.which] = false;
});

// Track mouse all the time.
document.addEventListener('mousemove', function storeMouse(event) {
    mousePosition = { x: event.clientX, y: event.clientY };
});

document.addEventListener('mousedown', function (event) {
    mouseDown[event.button] = true;
    ++mouseDownCount;
    checkMouseButtons();
});

document.addEventListener('mouseup', function (event) {
    mouseDown[event.button] = false;
    --mouseDownCount;
});

function checkMouseButtons() {
    if (mouseDownCount) {
        // alright, let's lift the little bugger up!
        for (var i = 0; i < mouseDown.length; ++i) {
            if (mouseDown[i]) {
                console.log("Button: " + i);
            }
        }
    }
}

// Array of keys to disable.
function disableKeys(keys) {
    document.addEventListener("keydown", function disableKey(event) {
        if (keys.indexOf(event.which) > -1) event.preventDefault();
    });
}

document.addEventListener('contextmenu', function (event) {
    //event.preventDefault();
    //var target = event.target;
    //alert("context: " + target.id);
});

window.alert = function (message, type, duration) {
    duration = duration || 1500;
    // TODO
    var elem = $('<div/>', {
        'class': 'alert popup',
        //title: 'Become a Googler',
        text: message
    }).appendTo('body');

    elem.delay(duration).fadeOut(300);
    setTimeout(function () {
        elem.remove();
    }, duration + 300);
};

function warn(message, duration) {}

window.onerror = function errorHandler(errorMsg, url, lineNumber, column, errObj) {
    console.log(errorMsg, lineNumber, column, errObj);
    return alert(errorMsg, "error", 4000);
};

// Object.extend helper method.
if (typeof Object.extend !== 'function') {
    Object.extend = function (d, s) {
        for (var k in s) {
            if (s.hasOwnProperty(k)) {
                var v = s[k];
                if (d.hasOwnProperty(k) && typeof d[k] === "object" && typeof v === "object") {
                    Object.extend(d[k], v);
                } else {
                    d[k] = v;
                }
            }
        }
        return d;
    };
}